#include "hal_data.h"
#include "nor.h"
#include "lfs.h"
#include "../src/RTT/SEGGER_RTT.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/* Clock Polarity (CPOL)
CPOL=0 SCLK is low when idle
CPOL=1 SCLK is high when idle
Clock Phase (CPHA)
CPHA=0 Data Sampled on the even edge of SCLK (Master Mode Only)
CPHA=1 Data Sampled on the odd edge of SCLK
*/

nor_t Nor;
lfs_t Lfs;
fsp_err_t err = FSP_SUCCESS;
static volatile spi_event_t g_master_event_flag;
static volatile bool g_transfer_complete = false;
void nor_cs_assert()
{

    R_IOPORT_PinWrite(&g_ioport_ctrl, EM_CS, BSP_IO_LEVEL_LOW);
    //R_BSP_SoftwareDelay(100, BSP_DELAY_UNITS_MILLISECONDS);
}

void nor_cs_Deassert()
{
    R_IOPORT_PinWrite(&g_ioport_ctrl, EM_CS, BSP_IO_LEVEL_HIGH);
}

void nor_rx(uint8_t* RxBuff, uint32_t len)
{
    err = R_SPI_Read(&g_spi0_ctrl, RxBuff, len, SPI_BIT_WIDTH_8_BITS);
    while (false == g_transfer_complete)
            {
                ;
            }
    g_transfer_complete = false;
    R_BSP_SoftwareDelay(300, BSP_DELAY_UNITS_MICROSECONDS);
}

void nor_tx(uint8_t* TxBuff, uint32_t len)
{
    err = R_SPI_Write(&g_spi0_ctrl, TxBuff, len, SPI_BIT_WIDTH_8_BITS);

    while (false == g_transfer_complete)
        {
            ;
        }
    g_transfer_complete = false;
    R_BSP_SoftwareDelay(300, BSP_DELAY_UNITS_MICROSECONDS);
}

void nor_delay(uint32_t us)
{
    R_BSP_SoftwareDelay(us, BSP_DELAY_UNITS_MICROSECONDS);
}

void init_nor()
{
    nor_err_e err;

    Nor.config.CsAssert = nor_cs_assert;
    Nor.config.CsDeassert = nor_cs_Deassert;
    Nor.config.DelayUs = nor_delay;
    Nor.config.SpiRxFxn = nor_rx;
    Nor.config.SpiTxFxn = nor_tx;
    R_IOPORT_PinWrite(&g_ioport_ctrl, EM_RST, BSP_IO_LEVEL_HIGH);
    nor_cs_Deassert();
    err = NOR_Init(&Nor);
    //err = NOR_Init_wo_ID(&Nor);
    if (err != NOR_OK)
    {
        while(1);
    }
}



void __read_nor_reg1(){
    uint32_t addr = 0;
    uint8_t bff[64];

    NOR_ReadBytes(&Nor, bff, addr, sizeof(bff));
}

void __read_nor_reg2(){
    uint32_t addr = 0x2500;
    uint8_t bff[90];

    NOR_ReadBytes(&Nor, bff, addr, sizeof(bff));
}

void __write_nor_reg1(){
    uint32_t addr = 0;
    uint32_t Value = 2500;

    if (NOR_IsEmptyPage(&Nor, 0, 0, 4) == NOR_REGIONS_IS_NOT_EMPTY){
        NOR_EraseAddress(&Nor, 0x0, NOR_ERASE_4K);
    }

    NOR_WriteBytes(&Nor, (uint8_t*)&Value, addr, sizeof(Value));
}

void __write_nor_reg2(){
    uint32_t addr = 0x2500;
    uint32_t page;
    uint32_t Value = 125;

    page = addr/Nor.info.u16PageSize;
    if (NOR_IsEmptyPage(&Nor, page, 0, 4) == NOR_REGIONS_IS_NOT_EMPTY){
        NOR_EraseAddress(&Nor, addr, NOR_ERASE_4K);
    }

    NOR_WriteBytes(&Nor, (uint8_t*)&Value, addr, sizeof(Value));
}

/** Start LittleFs **/

int fs_read(const struct lfs_config *c, lfs_block_t block,
            lfs_off_t off, void *buffer, lfs_size_t size){

    if (NOR_ReadSector(&Nor, (uint8_t*)buffer, block, off, size) == NOR_OK){
        return 0;
    }

    return LFS_ERR_IO;
}

int fs_write(const struct lfs_config *c, lfs_block_t block,
        lfs_off_t off, const void *buffer, lfs_size_t size){

    if (NOR_WriteSector(&Nor, (uint8_t*)buffer, block, off, size) == NOR_OK){
        return 0;
    }

    return LFS_ERR_IO;
}

int fs_erase(const struct lfs_config *c, lfs_block_t block){
    if (NOR_EraseSector(&Nor, block) == NOR_OK){
        return 0;
    }

    return LFS_ERR_IO;
}

int fs_sync(const struct lfs_config *c){
    return 0;
}

void init_littefs(){
    // because of static qualifier, this variable
    // will have a dedicated address
    static struct lfs_config LfsConfig = {0};
    int Error;

    LfsConfig.read_size = 64;
    LfsConfig.prog_size = 64;
    LfsConfig.block_size = Nor.info.u16SectorSize;
    LfsConfig.block_count = Nor.info.u32SectorCount;
    LfsConfig.cache_size = Nor.info.u16PageSize;
    LfsConfig.lookahead_size = Nor.info.u32SectorCount/8;
    LfsConfig.block_cycles = 10000;

    LfsConfig.read = fs_read;
    LfsConfig.prog = fs_write;
    LfsConfig.erase = fs_erase;
    LfsConfig.sync = fs_sync;

    Error = lfs_mount(&Lfs, &LfsConfig);
    if (Error != LFS_ERR_OK){
        lfs_format(&Lfs, &LfsConfig);
        Error = lfs_mount(&Lfs, &LfsConfig);
        if (Error != LFS_ERR_OK){
            Error_Handler();
        }
    }
}

void init_storage()
{
    init_nor();
    init_littlefs();
}

/* Callback function */
void spi_callback(spi_callback_args_t *p_args)
{
    if (SPI_EVENT_TRANSFER_COMPLETE == p_args->event)
       {
           g_transfer_complete = true;
       }
}

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
R_BSP_SoftwareDelay(200, BSP_DELAY_UNITS_MILLISECONDS);
R_SPI_Open(&g_spi0_ctrl, &g_spi0_cfg);
R_BSP_SoftwareDelay(200, BSP_DELAY_UNITS_MILLISECONDS);
R_SPI_Write(&g_spi0_ctrl, 0x00, 1, SPI_BIT_WIDTH_8_BITS);
R_BSP_SoftwareDelay(200, BSP_DELAY_UNITS_MILLISECONDS);

init_nor();

__read_nor_reg1();
R_BSP_SoftwareDelay(200, BSP_DELAY_UNITS_MILLISECONDS);
__read_nor_reg2();
R_BSP_SoftwareDelay(200, BSP_DELAY_UNITS_MILLISECONDS);

__write_nor_reg1();
R_BSP_SoftwareDelay(200, BSP_DELAY_UNITS_MILLISECONDS);
__write_nor_reg2();

R_BSP_SoftwareDelay(200, BSP_DELAY_UNITS_MILLISECONDS);
__read_nor_reg1();
R_BSP_SoftwareDelay(200, BSP_DELAY_UNITS_MILLISECONDS);
__read_nor_reg2();
R_BSP_SoftwareDelay(200, BSP_DELAY_UNITS_MILLISECONDS);
R_SPI_Close(&g_spi0_ctrl);

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
