#include "hal_data.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "../src/RTT/SEGGER_RTT.h"
#include "../ra/fsp/src/bsp/cmsis/Device/RENESAS/Include/R7FA2L1AB.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

// UART DRIVER DEFINES
#define LPUART_DATA_RX_SIZE 512
#define LPUART_DATA_TX_SIZE 512
#define TRANSFER_LENGTH 16
#define V_ref (1.8f)
#define ADC_12_BIT (4096u)
#define SIZE_64 (64U)
uint8_t  g_dest[LPUART_DATA_RX_SIZE];
uint8_t  g_src[LPUART_DATA_TX_SIZE];
uint8_t  g_out_of_band_received[TRANSFER_LENGTH];
uint32_t g_transfer_complete = 0;
uint32_t g_receive_complete  = 0;
uint32_t g_out_of_band_index = 0;
static uint16_t channel0_conversion_result;

char volt_str[5]= {0x00};
float adc_volt = {0x00};

fsp_err_t err = FSP_SUCCESS;     // Error status

////////////////////////////////////////////////////////////////
////
////  Send raw command
////////////////////////////////////////////////////////////////
bool at_SendRaw(uint8_t *data, uint16_t len) {
    if (len <= LPUART_DATA_TX_SIZE) {
        // Send the information in data through the UART
        memcpy(g_src, data, len);
        if (R_SCI_UART_Write(&g_uart0_ctrl, g_src, TRANSFER_LENGTH) == FSP_SUCCESS) {
            R_BSP_SoftwareDelay(1000, BSP_DELAY_UNITS_MILLISECONDS);
            return true;
        } else {
            return false;
        }
    } else {
        return false;
    }
}

void floatToCharArray(float value, char *str, int precision) {
    int intPart = (int)value;
    int intLength = 0;
    if (intPart == 0) {
        str[intLength++] = '0';
    } else {
        while (intPart > 0) {
            int digit = intPart % 10;
            str[intLength++] = digit + '0';
            intPart /= 10;
        }
    }

    // Reverse the integer part in the string
    for (int i = 0; i < intLength / 2; i++) {
        char temp = str[i];
        str[i] = str[intLength - i - 1];
        str[intLength - i - 1] = temp;
    }

    // Add the decimal point
    str[intLength] = '.';
    intLength++;

    float fractionalPart = value - (int)value;
    for (int i = 0; i < precision; i++) {
        fractionalPart *= 10;
        int digit = (int)fractionalPart;
        str[intLength++] = digit + '0';
        fractionalPart -= digit;
    }

    // Null-terminate the string
    str[intLength] = '\0';
}

////////////////////////////////////////////////////////////////
////
////  Send string command
////////////////////////////////////////////////////////////////
bool at_SendString(char *data) {
    return at_SendRaw((uint8_t*) data, strlen(data));
}

volatile bool scan_complete_flag = false;
void adc_callback (adc_callback_args_t * p_args)
{
    FSP_PARAMETER_NOT_USED(p_args);
    scan_complete_flag = true;
}

bsp_io_level_t PSM_IND_R_LEVEL = BSP_IO_LEVEL_LOW;

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    //R_IOPORT_PinRead(&g_ioport_ctrl, PSM_IND_R, &PSM_IND_R_LEVEL);

    R_IOPORT_PinWrite(&g_ioport_ctrl, LED, BSP_IO_LEVEL_HIGH);
    R_SCI_UART_Open(&g_uart0_ctrl, &g_uart0_cfg);
    /* Enable channels. */
    R_ADC_Open(&g_adc0_ctrl, &g_adc0_cfg);

    R_IOPORT_PinWrite(&g_ioport_ctrl, EN_BM, BSP_IO_LEVEL_HIGH);
    R_IOPORT_PinWrite(&g_ioport_ctrl, EN_PS_R, BSP_IO_LEVEL_HIGH);
    R_BSP_SoftwareDelay(300, BSP_DELAY_UNITS_MILLISECONDS);

    R_IOPORT_PinWrite(&g_ioport_ctrl, EN_DC_DC, BSP_IO_LEVEL_HIGH);
    R_BSP_SoftwareDelay(300, BSP_DELAY_UNITS_MILLISECONDS);

    R_IOPORT_PinWrite(&g_ioport_ctrl, PWRKEY_R, BSP_IO_LEVEL_HIGH);
    R_BSP_SoftwareDelay(750, BSP_DELAY_UNITS_MILLISECONDS);
    R_IOPORT_PinWrite(&g_ioport_ctrl, PWRKEY_R, BSP_IO_LEVEL_LOW);
    R_BSP_SoftwareDelay(100, BSP_DELAY_UNITS_MILLISECONDS);
    //R_IOPORT_PinWrite(&g_ioport_ctrl, RESET_R, BSP_IO_LEVEL_HIGH);
    //R_BSP_SoftwareDelay(100, BSP_DELAY_UNITS_MILLISECONDS);
    //R_IOPORT_PinWrite(&g_ioport_ctrl, RESET_R, BSP_IO_LEVEL_LOW);


while(1)
{

    //R_IOPORT_PinWrite(&g_ioport_ctrl, EN_PS_R, BSP_IO_LEVEL_HIGH);
    at_SendString("iuhoiuh\r\n");
    SEGGER_RTT_printf(0, "g_src : %s\r\n", g_src);

    //R_SCI_UART_Write(&g_uart0_ctrl, g_src, TRANSFER_LENGTH);
    //R_BSP_SoftwareDelay(100, BSP_DELAY_UNITS_MILLISECONDS);
    R_SCI_UART_Read(&g_uart0_ctrl, g_dest, TRANSFER_LENGTH);
    //R_BSP_SoftwareDelay(1000, BSP_DELAY_UNITS_MILLISECONDS);
    SEGGER_RTT_printf(0, "gdest : %s\r\n", g_dest);

    err = R_ADC_ScanCfg(&g_adc0_ctrl, &g_adc0_channel_cfg);
    if (FSP_SUCCESS != err)
            {
                /* ADC Failure message */
            print_string("** R_ADC_ScanCfg API failed ** \r\n");
            }

    /* In software trigger mode, start a scan by calling R_ADC_ScanStart(). In other modes, enable external
    * triggers by calling R_ADC_ScanStart(). */
    print_string("\r\nADC Started Scan\r\n");
    err = R_ADC_ScanStart(&g_adc0_ctrl);
    R_BSP_SoftwareDelay(300, BSP_DELAY_UNITS_MILLISECONDS);
    /* handle error */
   if (FSP_SUCCESS != err)
   {
       /* ADC Failure message */
       print_string("** R_ADC_ScanStart API failed ** \r\n");
   }

    /* Read converted data. */
    err = R_ADC_Read(&g_adc0_ctrl, ADC_CHANNEL_0, &channel0_conversion_result);
    if (FSP_SUCCESS != err)
        {
            /* ADC Failure message */
            print_string("** R_ADC_Read API failed ** \r\n");
        }
    //channel0_conversion_result = channel0_conversion_result/16;
    adc_volt = (float)((channel0_conversion_result*V_ref)/ADC_12_BIT);
    floatToCharArray(adc_volt , volt_str, 2);
    print_string_and_number("\r\nThe Voltage Reading from ADC: \r\n", channel0_conversion_result);
    SEGGER_RTT_printf(0, "\r\nADC input voltage with string: %s\r\n", volt_str);

    R_BSP_SoftwareDelay(1000, BSP_DELAY_UNITS_MILLISECONDS);
}



#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/* Callback function */
void example_callback (uart_callback_args_t * p_args)
{
    /* Handle the UART event */
    switch (p_args->event)
    {
        /* Received a character */
        case UART_EVENT_RX_CHAR:
        {
            /* Only put the next character in the receive buffer if there is space for it */
            if (sizeof(g_out_of_band_received) > g_out_of_band_index)
            {
                /* Write either the next one or two bytes depending on the receive data size */
                if (UART_DATA_BITS_8 >= g_uart0_cfg.data_bits)
                {
                    g_out_of_band_received[g_out_of_band_index++] = (uint8_t) p_args->data;
                }
                else
                {
                    uint16_t * p_dest = (uint16_t *) &g_out_of_band_received[g_out_of_band_index];
                    *p_dest              = (uint16_t) p_args->data;
                    g_out_of_band_index += 2;
                }
            }
            break;
        }
        /* Receive complete */
        case UART_EVENT_RX_COMPLETE:
        {
            g_receive_complete = 1;
            break;
        }
        /* Transmit complete */
        case UART_EVENT_TX_COMPLETE:
        {
            g_transfer_complete = 1;
            break;
        }
        default:
        {
        }
    }
}



/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
